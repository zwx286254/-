<!-- TOC -->

- [乐观锁](#乐观锁)
- [悲观锁](#悲观锁)
- [CAS原理](#cas原理)
    - [CAS概述](#cas概述)
    - [CAS底层实现](#cas底层实现)
    - [CAS实现(Java/C++)](#cas实现javac)
- [自旋锁](#自旋锁)
    - [自旋锁和互斥锁](#自旋锁和互斥锁)
    - [自旋锁的实现](#自旋锁的实现)
    - [自旋锁的问题](#自旋锁的问题)
- [排队自旋锁](#排队自旋锁)
    - [排队自旋锁实现](#排队自旋锁实现)
    - [排队自旋锁问题](#排队自旋锁问题)
- [CLH自旋锁](#clh自旋锁)
    - [CLH自旋锁实现](#clh自旋锁实现)
    - [CLH自旋锁问题](#clh自旋锁问题)
- [MSC自旋锁](#msc自旋锁)
    - [MSC自旋锁实现](#msc自旋锁实现)

<!-- /TOC -->
# 乐观锁
> 一种**无锁**的设计思想，在多线程并发时，总是认为最好情况，即锁的竞争不存在，乐观锁适用于**多读少写**的场景。具体的两种实现方式如下：
> 1. **CAS：** 使用底层CPU硬件提供的CAS指令实现一种原子操作 - [CAS原理](#CAS原理)
> 2. **版本控制：** 在数据上绑定版本号，业务线程在读取数据库中数据和对应的版本号进行业务处理后，更新数据回数据库时：
>    + 首先判断业务线程中数据的版本号和数据库中当前版本号是否一致
>    + 一致，则更新成功，数据库中数据版本+1
>    + 不一致，则更新失败，业务线程放弃当前持有的数据，重新读取数据库中数据和对应的版本，重新进行业务处理和上述更新操作，直到更新成功

# 悲观锁
>一种**有锁**的设计思想，在多线程并发时，总是认为最坏的情况，同一时刻只允许一个线程获得锁，其他线程被阻塞挂起，悲观锁适用于竞争比较激烈且同步代码执行时间较长的场景
# CAS原理
## CAS概述
> **CAS(Compare And Swap):** 比较并交换，
## CAS底层实现
## CAS实现(Java/C++)
# 自旋锁
## 自旋锁和互斥锁
## 自旋锁的实现
## 自旋锁的问题
# 排队自旋锁
## 排队自旋锁实现
## 排队自旋锁问题
# CLH自旋锁
## CLH自旋锁实现
## CLH自旋锁问题
# MSC自旋锁
## MSC自旋锁实现

~未完待续~